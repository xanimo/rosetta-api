/*
 * Rosetta
 *
 * Build Once. Integrate Your Blockchain Everywhere.
 *
 * OpenAPI spec version: 1.4.10
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// SearchTransactionsRequest is used to search for transactions matching a set of provided conditions in canonical blocks.
    /// </summary>
    [DataContract]
    public partial class SearchTransactionsRequest : IEquatable<SearchTransactionsRequest>
    { 
        /// <summary>
        /// Gets or Sets NetworkIdentifier
        /// </summary>
        [Required]
        [DataMember(Name="network_identifier")]
        public NetworkIdentifier NetworkIdentifier { get; set; }

        /// <summary>
        /// Gets or Sets Operator
        /// </summary>
        [DataMember(Name="operator")]
        public Operator Operator { get; set; }

        /// <summary>
        /// max_block is the largest block index to consider when searching for transactions. If this field is not populated, the current block is considered the max_block. If you do not specify a max_block, it is possible a newly synced block will interfere with paginated transaction queries (as the offset could become invalid with newly added rows).
        /// </summary>
        /// <value>max_block is the largest block index to consider when searching for transactions. If this field is not populated, the current block is considered the max_block. If you do not specify a max_block, it is possible a newly synced block will interfere with paginated transaction queries (as the offset could become invalid with newly added rows).</value>
        [DataMember(Name="max_block")]
        public long? MaxBlock { get; set; }

        /// <summary>
        /// offset is the offset into the query result to start returning transactions. If any search conditions are changed, the query offset will change and you must restart your search iteration.
        /// </summary>
        /// <value>offset is the offset into the query result to start returning transactions. If any search conditions are changed, the query offset will change and you must restart your search iteration.</value>
        [DataMember(Name="offset")]
        public long? Offset { get; set; }

        /// <summary>
        /// limit is the maximum number of transactions to return in one call. The implementation may return &lt;&#x3D; limit transactions.
        /// </summary>
        /// <value>limit is the maximum number of transactions to return in one call. The implementation may return &lt;&#x3D; limit transactions.</value>
        [DataMember(Name="limit")]
        public long? Limit { get; set; }

        /// <summary>
        /// Gets or Sets TransactionIdentifier
        /// </summary>
        [DataMember(Name="transaction_identifier")]
        public TransactionIdentifier TransactionIdentifier { get; set; }

        /// <summary>
        /// Gets or Sets AccountIdentifier
        /// </summary>
        [DataMember(Name="account_identifier")]
        public AccountIdentifier AccountIdentifier { get; set; }

        /// <summary>
        /// Gets or Sets CoinIdentifier
        /// </summary>
        [DataMember(Name="coin_identifier")]
        public CoinIdentifier CoinIdentifier { get; set; }

        /// <summary>
        /// Gets or Sets Currency
        /// </summary>
        [DataMember(Name="currency")]
        public Currency Currency { get; set; }

        /// <summary>
        /// status is the network-specific operation type.
        /// </summary>
        /// <value>status is the network-specific operation type.</value>
        [DataMember(Name="status")]
        public string Status { get; set; }

        /// <summary>
        /// type is the network-specific operation type.
        /// </summary>
        /// <value>type is the network-specific operation type.</value>
        [DataMember(Name="type")]
        public string Type { get; set; }

        /// <summary>
        /// address is AccountIdentifier.Address. This is used to get all transactions related to an AccountIdentifier.Address, regardless of SubAccountIdentifier.
        /// </summary>
        /// <value>address is AccountIdentifier.Address. This is used to get all transactions related to an AccountIdentifier.Address, regardless of SubAccountIdentifier.</value>
        [DataMember(Name="address")]
        public string Address { get; set; }

        /// <summary>
        /// success is a synthetic condition populated by parsing network-specific operation statuses (using the mapping provided in &#x60;/network/options&#x60;).
        /// </summary>
        /// <value>success is a synthetic condition populated by parsing network-specific operation statuses (using the mapping provided in &#x60;/network/options&#x60;).</value>
        [DataMember(Name="success")]
        public bool? Success { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SearchTransactionsRequest {\n");
            sb.Append("  NetworkIdentifier: ").Append(NetworkIdentifier).Append("\n");
            sb.Append("  Operator: ").Append(Operator).Append("\n");
            sb.Append("  MaxBlock: ").Append(MaxBlock).Append("\n");
            sb.Append("  Offset: ").Append(Offset).Append("\n");
            sb.Append("  Limit: ").Append(Limit).Append("\n");
            sb.Append("  TransactionIdentifier: ").Append(TransactionIdentifier).Append("\n");
            sb.Append("  AccountIdentifier: ").Append(AccountIdentifier).Append("\n");
            sb.Append("  CoinIdentifier: ").Append(CoinIdentifier).Append("\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Address: ").Append(Address).Append("\n");
            sb.Append("  Success: ").Append(Success).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((SearchTransactionsRequest)obj);
        }

        /// <summary>
        /// Returns true if SearchTransactionsRequest instances are equal
        /// </summary>
        /// <param name="other">Instance of SearchTransactionsRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SearchTransactionsRequest other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    NetworkIdentifier == other.NetworkIdentifier ||
                    NetworkIdentifier != null &&
                    NetworkIdentifier.Equals(other.NetworkIdentifier)
                ) && 
                (
                    Operator == other.Operator ||
                    Operator != null &&
                    Operator.Equals(other.Operator)
                ) && 
                (
                    MaxBlock == other.MaxBlock ||
                    MaxBlock != null &&
                    MaxBlock.Equals(other.MaxBlock)
                ) && 
                (
                    Offset == other.Offset ||
                    Offset != null &&
                    Offset.Equals(other.Offset)
                ) && 
                (
                    Limit == other.Limit ||
                    Limit != null &&
                    Limit.Equals(other.Limit)
                ) && 
                (
                    TransactionIdentifier == other.TransactionIdentifier ||
                    TransactionIdentifier != null &&
                    TransactionIdentifier.Equals(other.TransactionIdentifier)
                ) && 
                (
                    AccountIdentifier == other.AccountIdentifier ||
                    AccountIdentifier != null &&
                    AccountIdentifier.Equals(other.AccountIdentifier)
                ) && 
                (
                    CoinIdentifier == other.CoinIdentifier ||
                    CoinIdentifier != null &&
                    CoinIdentifier.Equals(other.CoinIdentifier)
                ) && 
                (
                    Currency == other.Currency ||
                    Currency != null &&
                    Currency.Equals(other.Currency)
                ) && 
                (
                    Status == other.Status ||
                    Status != null &&
                    Status.Equals(other.Status)
                ) && 
                (
                    Type == other.Type ||
                    Type != null &&
                    Type.Equals(other.Type)
                ) && 
                (
                    Address == other.Address ||
                    Address != null &&
                    Address.Equals(other.Address)
                ) && 
                (
                    Success == other.Success ||
                    Success != null &&
                    Success.Equals(other.Success)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (NetworkIdentifier != null)
                    hashCode = hashCode * 59 + NetworkIdentifier.GetHashCode();
                    if (Operator != null)
                    hashCode = hashCode * 59 + Operator.GetHashCode();
                    if (MaxBlock != null)
                    hashCode = hashCode * 59 + MaxBlock.GetHashCode();
                    if (Offset != null)
                    hashCode = hashCode * 59 + Offset.GetHashCode();
                    if (Limit != null)
                    hashCode = hashCode * 59 + Limit.GetHashCode();
                    if (TransactionIdentifier != null)
                    hashCode = hashCode * 59 + TransactionIdentifier.GetHashCode();
                    if (AccountIdentifier != null)
                    hashCode = hashCode * 59 + AccountIdentifier.GetHashCode();
                    if (CoinIdentifier != null)
                    hashCode = hashCode * 59 + CoinIdentifier.GetHashCode();
                    if (Currency != null)
                    hashCode = hashCode * 59 + Currency.GetHashCode();
                    if (Status != null)
                    hashCode = hashCode * 59 + Status.GetHashCode();
                    if (Type != null)
                    hashCode = hashCode * 59 + Type.GetHashCode();
                    if (Address != null)
                    hashCode = hashCode * 59 + Address.GetHashCode();
                    if (Success != null)
                    hashCode = hashCode * 59 + Success.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(SearchTransactionsRequest left, SearchTransactionsRequest right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(SearchTransactionsRequest left, SearchTransactionsRequest right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
